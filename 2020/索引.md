### 1.Pandas单级索引 <br>

(1)读取csv数据的时候，使用参数index_col指定表中的列作为索引(效果等同于使用set_index方法指定某一列为索引，但是index_col的方法更简洁)
```
import numpy as np
import pandas as pd
```
```
df=pd.read_csv('sample_0630.csv',index_col = '2')
df.head(2)
```
待插入图片
```
df1=pd.read_csv('sample_0630.csv')
df2=df1.set_index(['2'])
df2.head(2)
```
待插入图片<br>

(2)最常用的索引方法有三类<br>
类型|可接收参数
-|-|
loc|布尔列表，索引子集构成的列表（索引标签）
iloc|整数或整数列表
[]操作符|常用语列选择或者布尔选择，尽量避免行的选择

➀loc表示标签索引<br> loc[a,b]两个引数，a代表行，b代表列
*所有在loc里使用的切片全部包含右端点<br>
>A.单行索引
```
df['2010-05-22T14:30:00+0900']
```
待插入图片<br>
>B.多行索引。多行索引时必须是一个list，而不是两个或多个索引，否则会报错
```
df.loc["2010-05-22T14:30:00+0900","2010-05-21T14:30:00+0900"]
KeyError: '2010-05-21T14:30:00+0900'
```
```
df.loc[["2010-05-22T14:30:00+0900","2010-05-21T14:30:00+0900"]]
```
>list的切片方法可以沿用
>>表示从索引标签=2010-05-21T14:30:00+0900的元素开始，以步长为2返回2010-05-30T14:00:00+0900的元素
注意到这里的2010-05-21T14:30:00+0900和2010-05-30T14:00:00+0900是标签索引，和list所用默认整数索引不一样
```
df.loc['2010-05-21T14:30:00+0900':'2010-05-30T14:00:00+0900':2].head()
```
>C.单列索引。使用loc方法获取列，比直接使用列标签获取列更复杂
```
df.loc[:,'1'].head(10)
```
等价的更简单的获取列的方法
```
df['1'].head(10)
or简洁地使用列名标签索引的方式
df3=pd.read_csv('train.csv',index_col='documentId',encoding ='utf-8')
df3.text.head()
*df3.text.head()成立是要建立在设置的标签索引列以外的情况，比如这里设置的索引列是documentId<br>
此时text列即可以通过df3.text.head()来获取，此时df3.documentId.head()会出错。
```
>D.多列索引
```
df.loc[:,['1','3']].head()
等价于
df[['3','4']].head()
也等价于使用列名标签做切片（这是list里没有的）
df.loc[:,'1':'3'].head()
也可使用iloc方式进行切片，这时候传入的应该是默认整数索引，从0开始，并且切片的接尾是不包含的

```
>E.联合索引
>>起点=2010-05-22T14:30:00+0900，终点=2010-05-25T14:00:00+0900，步长=2
>>*用loc的方式的话这里的2010-05-22T14:30:00+0900，2010-05-25T14:00:00+0900都是标签索引不是整数索引
```
df.loc['2010-05-22T14:30:00+0900':'2010-05-25T14:00:00+0900':2,'1':'4'].head()
```
>F.函数式索引
loc中使用的函数，传入参数就是前面的df；
本质上这是一个布尔索引：lambda函数分别根据每行的列3的值列返回一个布尔值，然后用这个布尔值序列来筛选df的行，布尔值为真则返回，否则筛选掉
```
df.loc[lambda x:x['3']=='友人代表のスピーチ、独女はどうこなしている？' ].head(20)
```
>G.实际上使用loc等方法筛选行或者列的时候，都是根据待筛选的行或者列对给定的筛选条件是否为真来决定是否返回该行或该列的。
```
def f(x):
    return ['2010-05-22T14:30:00+0900','2010-05-25T14:00:00+0900']
df.loc[f]
```
>布尔索引
isin用于判断DataFrame中的每个元素是否包含在数值中
下面这个例子的意思就是在取所有列0里值为dokujo-tsushin和○○的行<br>
注意isin里必须是列表元素 即isin([])的写法
```
df.loc[df['0'].isin(['dokujo-tsushin'，'○○'])].head(2)
```
建议for i in df['1'].values进行查看
```
df.loc[[True if i[-1]=='h' or i[0]=='h'
        else False 
        for i in df['1'].values]]
```
>小结
>本质上，loc中能传入的只有布尔列表和索引子集构成的列表。<br>

➁iloc表示位置索引(index)
>A.单行索引
```
df.iloc[3]
```
>B.多行索引
>注意结尾时不包含的 这和list的切片保持一致
```
df.iloc[2:4]
```
>C.单列索引
```
df.iloc[:,3].head(2)
```
>D.多列索引
```
表示从第二列到第4列隔2行取
df.iloc[:,1:3:2].head()
```
```
表示取第2列和第5列
df.iloc[:,[1,4]].head()
```
>E.混合索引
```
从第3行开始向后以步长为2选择行，从第5列开始向前以步长为2选择列
df.iloc[2::2,4::-2].head(3)
```
>函数式索引
>>注意：由于是iloc，返回值必须是由默认整数索引作为元素构成的 *类list* 的数据结构<br>
>>如果返回值不存在，则会报错 indexError positional indexers are out-of-bounds
```
df.iloc[lambda x:[3,4]].head()
df.iloc[lambda x:range(3)]#得到0,1,2行的结果
其他比如list(range(3))，tuple(range(3))等类list的数据结构都可以，但是set(range(3))不可以
df.iloc[lambda x:np.arange(3)]#得到0,1,2行的结果

df.iloc[lambda x:set(range(3))]
    →TypeError: int() argument must be a string, a bytes-like object or a number, not 'set'
```
>小结：iloc中接收的参数只能为整数或者整数列表，不能使用布尔索引
➂[]操作符<br>
如果不想陷入困境，不要再行索引为浮点时使用[]操作符，因为在Series中的浮点[]并不是进行位置比较，而是值比较，非常特殊。
>1.Series的[]操作:Series是一个一维数组
>>A.单元素索引
```
如果没有指明loc还是iloc，默认传入的是索引标签
s = pd.Series(df['3'],index=df.index)
使用[]操作符方法提取行
s[220]

使用loc方法提取行
s.loc['2010-05-22T14:30:00+0900']

#使用iloc方法
s.iloc[220]
```
>>B.多行索引<br>
```
使用的是绝对位置的整数切片，与元素无关，此处容易混淆，前闭后开
s[0:3]
```
>>C.函数式索引
```
注意使用lambda函数时，直接切片（比如：s[lambda x: 20::-3]）就报错，此时使用的不是绝对位置切片，而是元素切片。此处非常容易弄错。
s[lambda x:x.index[20::-3]]

并非是因为方括号不能直接接整数索引切片，而是因为lambda函数返回的是索引，因此能够根据索引正确德返回s的一段切片。
因为lambda函数返回值是索引，索引通过方括号传递给s，就可以取回s的相应索引位置的元素。
s[lambda x: 20::-3]
    →报错
    →s[lambda x: x[20::-3]]
        →返回一个Series（参考jupyter notebook结果）
    →s[lambda x: x[20::-3].index]
        →返回结果同s[lambda x:x.index[20::-3]]
```
>>D.布尔索引
```
s1 =pd.Series(df['Unnamed: 0'],index =df.index)
s1
s1[s1>80]
#复杂的布尔索引
s1[(s1>80&s1<100)]
#中间没有分别用括号括起来时会报错
s1[(s1>80&s1<100)]
    →ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
```
>2.DataFrame的[]操作:
>>A.单行索引
```
#这里非常容易写成df['3']，会报错。同Series使用的是绝对位置切片，而且是前闭后开
df[1:2]

#如果使用了标签索引（恰好标签索引又是整数的话），程序仍会认为传入的是默认整数索引，就会得到意料之外的结果
#下面这个没有报错，是因为并没有像上边直接去找整数索引等于2的，而是用一个空的索引集合去取df的子集。因此得到的是第3行以后的所有行
df[2:]

#如果想要获得某一行，更好的办法是get_loc的方法（index.get_loc:Get integer location, slice or boolean mask for requested label）
#2010-05-23T11:00:00+0900是具体某一行的标签索引
row = df.index.get_loc('2010-05-23T11:00:00+0900')
df[row:row+1]

#另外可以通过以下来查看到所有标签索引
df.index.get_loc

#使用loc方法得到的是个Series
df.loc['2010-05-23T11:00:00+0900',:]
#为了使得到的一行仍然是个df，需要传入区间
df.loc['2010-05-21T14:30:00+0900':'2010-05-21T14:30:00+0900',:]
```
>>B.多行索引
```
#用切片，如果是选取指定的某几行，推荐使用loc，否则很可能报错。尽管[]的写法可以正确执行，但是不推荐
#前闭后开
df[3:5]

#推荐使用iloc或者loc来明确地说明用的是默认整数索引（iloc：尾端不包含）还是标签索引（loc：尾端包含）
```
>>C.单列索引
```
#使用列明标签来返回单列，之所以选择列的语法如此简单，是因为df本质上市将多个Series作为列拼接起来的。
df['3'].head()

#将列传递给df构造器
pd.DataFrame(df['3']).head()

#使用to_frame方法也可将Series转为df
df['3'].to_frame().head(2)

#使用iloc方法返回同一列
※注意由于是iloc，所以这里传入了列的默认整数索引
df.iloc[:,1].head()

#使用loc时，需要使用标签索引
※如果df只有默认整数索引，这时候默认整数索引同时也是标签索引
df.loc[:,'3'].to_frame().head(2)

#只有默认整数索引，因此默认整数索引也是标签索引的一个实例
df1=pd.DataFrame(np.random.randint(1,10,12).reshape(3,4))
df1
#对上述df1使用iloc自然会返回第二列
df1.iloc[:,1]
#对上述df1，使用loc时也会正确返回第二列，
df1.loc[:,1]
#传入的是切片的时候，会默认使用的是默认整数索引，因此尾端是不包含的,除非显式地使用loc，才会包含尾端
df1[0:1] →仅第一行
df1.loc[0:1]→显示到第二行
#单列索引一个更简单的选择方法（loc部分有讲）
df3=pd.read_csv('train.csv',index_col='documentId',encoding ='utf-8')
df3['text'].head(3)
df3.text.head()
    ※如果列名标签中有空格或者列名是数字，就没法用这种方式
    假设：df.column =['School Name','Class','Gender','Address','Height']，此时用df.School Name就会报错：SyntaxError：invaid syntax
    这种情况只能用df['School Name'].head()
```
>>多列索引
```
#索引多列时，传入的必须是一个list，而不是多个列名标签，也就是说方括号应该有两层
df[['3','4']].head()

#使用loc方式
df.loc[:,['3','4']].head()

#使用iloc方式：传入的列名时默认整数索引，从0开始
df.iloc[:,[0,3,4]].head()  →iloc方法取间隔列

df.iloc[:,0:3].head() →iloc方法取连续列
```
>>函数式索引<br>
```
#这里的lambda是一个常数值的函数
df[lambda x:['4','3']].head()

#一个选取列名长度大于5的函数，其实这仍然是个常值函数
df[lambda x:[x for x in df.columns if len(x)>2]]

#参考
for x in df.columns:
    print(len(x))
```
>>布尔索引
```
df[df['3'] == 'ネットで断ち切れない元カレとの縁'].head()

#同样如果列名是英文(eg:Gender)时可使用以下形式
df[df.Gender == 'F].head()
```
>>小结：[]操作符常用于列选择或者布尔选择，尽量避免行的选择

### 关于布尔索引
1.布尔符号：'&','|'，'~'分别代表和and，或or，取反not
```
df[(df['3'] == 'ネットで断ち切れない元カレとの縁')&(df['1'] == 'http://news.livedoor.com/article/detail/4788362/')].head()

df[(df['Unnamed: 0']>80)|(df['HOT'] ==1)].head()

~的用法
➀df[~((df['Unnamed: 0']>80)|(df['HOT'] ==1))].head()
➁


    
    








