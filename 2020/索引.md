### 1.Pandas单级索引 <br>

(1)读取csv数据的时候，使用参数index_col指定表中的列作为索引(效果等同于使用set_index方法指定某一列为索引，但是index_col的方法更简洁)
```
import numpy as np
import pandas as pd
```
```
df=pd.read_csv('sample_0630.csv',index_col = '2')
df.head(2)
```
待插入图片
```
df1=pd.read_csv('sample_0630.csv')
df2=df1.set_index(['2'])
df2.head(2)
```
待插入图片<br>

(2)最常用的索引方法有三类<br>
类型|可接收参数
-|-|
loc|布尔列表，索引子集构成的列表（索引标签）
iloc|整数或整数列表
[]操作符|

➀loc表示标签索引<br> loc[a,b]两个引数，a代表行，b代表列
*所有在loc里使用的切片全部包含右端点<br>
>A.单行索引
```
df['2010-05-22T14:30:00+0900']
```
待插入图片<br>
>B.多行索引。多行索引时必须是一个list，而不是两个或多个索引，否则会报错
```
df.loc["2010-05-22T14:30:00+0900","2010-05-21T14:30:00+0900"]
KeyError: '2010-05-21T14:30:00+0900'
```
```
df.loc[["2010-05-22T14:30:00+0900","2010-05-21T14:30:00+0900"]]
```
>list的切片方法可以沿用
>>表示从索引标签=2010-05-21T14:30:00+0900的元素开始，以步长为2返回2010-05-30T14:00:00+0900的元素
注意到这里的2010-05-21T14:30:00+0900和2010-05-30T14:00:00+0900是标签索引，和list所用默认整数索引不一样
```
df.loc['2010-05-21T14:30:00+0900':'2010-05-30T14:00:00+0900':2].head()
```
>C.单列索引。使用loc方法获取列，比直接使用列标签获取列更复杂
```
df.loc[:,'1'].head(10)
```
等价的更简单的获取列的方法
```
df['1'].head(10)
or简洁地使用列名标签索引的方式
df3=pd.read_csv('train.csv',index_col='documentId',encoding ='utf-8')
df3.text.head()
*df3.text.head()成立是要建立在设置的标签索引列以外的情况，比如这里设置的索引列是documentId<br>
此时text列即可以通过df3.text.head()来获取，此时df3.documentId.head()会出错。
```
>D.多列索引
```
df.loc[:,['1','3']].head()
等价于
df[['3','4']].head()
也等价于使用列名标签做切片（这是list里没有的）
df.loc[:,'1':'3'].head()
也可使用iloc方式进行切片，这时候传入的应该是默认整数索引，从0开始，并且切片的接尾是不包含的

```
>E.联合索引
>>起点=2010-05-22T14:30:00+0900，终点=2010-05-25T14:00:00+0900，步长=2
>>*用loc的方式的话这里的2010-05-22T14:30:00+0900，2010-05-25T14:00:00+0900都是标签索引不是整数索引
```
df.loc['2010-05-22T14:30:00+0900':'2010-05-25T14:00:00+0900':2,'1':'4'].head()
```
>F.函数式索引
loc中使用的函数，传入参数就是前面的df；
本质上这是一个布尔索引：lambda函数分别根据每行的列3的值列返回一个布尔值，然后用这个布尔值序列来筛选df的行，布尔值为真则返回，否则筛选掉
```
df.loc[lambda x:x['3']=='友人代表のスピーチ、独女はどうこなしている？' ].head(20)
```
>G.实际上使用loc等方法筛选行或者列的时候，都是根据待筛选的行或者列对给定的筛选条件是否为真来决定是否返回该行或该列的。
```
def f(x):
    return ['2010-05-22T14:30:00+0900','2010-05-25T14:00:00+0900']
df.loc[f]
```
>布尔索引
isin用于判断DataFrame中的每个元素是否包含在数值中
下面这个例子的意思就是在取所有列0里值为dokujo-tsushin和○○的行<br>
注意isin里必须是列表元素 即isin([])的写法
```
df.loc[df['0'].isin(['dokujo-tsushin'，'○○'])].head(2)
```
建议for i in df['1'].values进行查看
```
df.loc[[True if i[-1]=='h' or i[0]=='h'
        else False 
        for i in df['1'].values]]
```
>小结
>本质上，loc中能传入的只有布尔列表和索引子集构成的列表。<br>

➁iloc表示位置索引(index)
>A.单行索引
```
df.iloc[3]
```
>B.多行索引
>注意结尾时不包含的 这和list的切片保持一致
```
df.iloc[2:4]
```
>C.单列索引
```
df.iloc[:,3].head(2)
```
>D.多列索引
```
表示从第二列到第4列隔2行取
df.iloc[:,1:3:2].head()
```
```
表示取第2列和第5列
df.iloc[:,[1,4]].head()
```
>E.混合索引
```
从第3行开始向后以步长为2选择行，从第5列开始向前以步长为2选择列
df.iloc[2::2,4::-2].head(3)
```
>函数式索引
>>注意：由于是iloc，返回值必须是由默认整数索引作为元素构成的 *类list* 的数据结构<br>
>>如果返回值不存在，则会报错 indexError positional indexers are out-of-bounds
```
df.iloc[lambda x:[3,4]].head()
df.iloc[lambda x:range(3)]#得到0,1,2行的结果
其他比如list(range(3))，tuple(range(3))等类list的数据结构都可以，但是set(range(3))不可以
df.iloc[lambda x:np.arange(3)]#得到0,1,2行的结果

df.iloc[lambda x:set(range(3))]
    →TypeError: int() argument must be a string, a bytes-like object or a number, not 'set'
```
>小结：iloc中接收的参数只能为整数或者整数列表，不能使用布尔索引
➂[]操作符<br>
如果不想陷入困境，不要再行索引为浮点时使用[]操作符，因为在Series中的浮点[]并不是进行位置比较，而是值比较，非常特殊。
>1.Series的[]操作:Series是一个一维数组
>>A.单元素索引
```
如果没有指明loc还是iloc，默认传入的是索引标签
s = pd.Series(df['3'],index=df.index)
使用[]操作符方法提取行
s[220]

使用loc方法提取行
s.loc['2010-05-22T14:30:00+0900']

#使用iloc方法
s.iloc[220]
```
>>B.多行索引<br>
```
使用的是绝对位置的整数切片，与元素无关，此处容易混淆，前闭后开
s[0:3]
```
>>C.函数式索引
```
注意使用lambda函数时，直接切片（比如：s）就报错，此时使用的不是绝对位置切片，而是元素切片。此处非常容易弄错。
s[lambda x:x.index[20::-3]]







